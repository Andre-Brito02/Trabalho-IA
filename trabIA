import random
import math

# --- Cálculo de distâncias ---

def deg_to_rad(deg):
    deg_int = int(deg)
    min_part = deg - deg_int
    return math.pi * (deg_int + 5.0 * min_part / 3.0) / 180.0

def geo_distance(lat1, lon1, lat2, lon2):
    R = 6378.388
    lat1 = deg_to_rad(lat1)
    lon1 = deg_to_rad(lon1)
    lat2 = deg_to_rad(lat2)
    lon2 = deg_to_rad(lon2)

    q1 = math.cos(lon1 - lon2)
    q2 = math.cos(lat1 - lat2)
    q3 = math.cos(lat1 + lat2)

    return int(R * math.acos(0.5 * ((1.0 + q1) * q2 - (1.0 - q1) * q3)) + 1)

def euclidean_distance(x1, y1, x2, y2):
    return int(math.sqrt((x1 - x2)**2 + (y1 - y2)**2) + 0.5)

def att_distance(x1, y1, x2, y2):
    xd = x1 - x2
    yd = y1 - y2
    rij = math.sqrt((xd * xd + yd * yd) / 10.0)
    tij = int(rij + 0.5)
    return tij if tij >= rij else tij + 1

# --- Leitura do arquivo .tsp ---

def ler_coordenadas_tsp(caminho_arquivo):
    coordenadas = []
    tipo_distancia = "EUC_2D"
    lendo_coordenadas = False

    try:
        with open(caminho_arquivo, 'r') as arquivo:
            for linha in arquivo:
                linha = linha.strip()
                if linha.startswith("EDGE_WEIGHT_TYPE"):
                    tipo_distancia = linha.split(":")[-1].strip()
                if linha == "NODE_COORD_SECTION":
                    lendo_coordenadas = True
                    continue
                if linha == "EOF":
                    break
                if lendo_coordenadas:
                    partes = linha.split()
                    if len(partes) == 3:
                        _, x, y = partes
                        coordenadas.append((float(x), float(y)))
        return coordenadas, tipo_distancia
    except Exception as e:
        print(f"Erro ao ler {caminho_arquivo}: {e}")
        return None, None

# --- Geração da matriz de distância ---

def gerar_matriz_distancia(coordenadas, tipo):
    n = len(coordenadas)
    matriz = [[0.0 for _ in range(n)] for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i != j:
                x1, y1 = coordenadas[i]
                x2, y2 = coordenadas[j]
                if tipo == "GEO":
                    matriz[i][j] = geo_distance(x1, y1, x2, y2)
                elif tipo == "ATT":
                    matriz[i][j] = att_distance(x1, y1, x2, y2)
                else:  # EUC_2D padrão
                    matriz[i][j] = euclidean_distance(x1, y1, x2, y2)
    return matriz

# --- Restante do Algoritmo Genético (sem alterações significativas) ---

def calcula_custo_rota(rota, matriz_dist):
    custo = 0
    for i in range(len(rota) - 1):
        custo += matriz_dist[rota[i]][rota[i+1]]
    custo += matriz_dist[rota[-1]][rota[0]]
    return custo

def exibir_matriz(matriz):
    for linha in matriz:
        print(["{:.2f}".format(val) for val in linha])

def inicializa_populacao(tamanho_populacao, tamanho_rota):
    return [random.sample(range(tamanho_rota), tamanho_rota) for _ in range(tamanho_populacao)]

def seleciona_pais(populacao, matriz_dist):
    pontuacoes = [(rota, calcula_custo_rota(rota, matriz_dist)) for rota in populacao]
    pontuacoes.sort(key=lambda x: x[1])
    return pontuacoes[:2]

def crossover(pai1, pai2):
    tamanho = len(pai1)
    filho = [-1] * tamanho
    inicio, fim = sorted([random.randint(0, tamanho - 1) for _ in range(2)])
    for i in range(inicio, fim + 1):
        filho[i] = pai1[i]
    idx = 0
    for i in range(tamanho):
        if filho[i] == -1:
            while pai2[idx] in filho:
                idx += 1
            filho[i] = pai2[idx]
    return filho

def mutacao(rota):
    idx1, idx2 = random.sample(range(len(rota)), 2)
    rota[idx1], rota[idx2] = rota[idx2], rota[idx1]

# --- Parâmetros do AG ---

tamanho_populacao = 100
tamanho_geracao = 200
taxa_mutacao = 0.05

# --- Arquivos TSP para processar ---

caminhos_tsp = [
    r'C:\temp\burma14.tsp',
    r'C:\temp\att48.tsp',
    r'C:\temp\bier127.tsp'
]

for caminho in caminhos_tsp:
    print(f"\n--- Processando {caminho} ---")
    coordenadas, tipo_distancia = ler_coordenadas_tsp(caminho)

    if coordenadas:
        print(f"Tipo de distância: {tipo_distancia}")
        print(f"Total de cidades: {len(coordenadas)}")
        matriz_dist = gerar_matriz_distancia(coordenadas, tipo_distancia)

        populacao = inicializa_populacao(tamanho_populacao, len(coordenadas))

        for geracao in range(tamanho_geracao):
            nova_populacao = []
            for _ in range(tamanho_populacao // 2):
                pais = seleciona_pais(populacao, matriz_dist)
                pai1, pai2 = pais[0][0], pais[1][0]

                filho1 = crossover(pai1, pai2)
                filho2 = crossover(pai2, pai1)

                if random.random() < taxa_mutacao:
                    mutacao(filho1)
                if random.random() < taxa_mutacao:
                    mutacao(filho2)

                nova_populacao.extend([filho1, filho2])

            populacao = nova_populacao

        melhor_rota = min(populacao, key=lambda x: calcula_custo_rota(x, matriz_dist))
        custo_melhor_rota = calcula_custo_rota(melhor_rota, matriz_dist)

        print(f"Melhor rota (custo {custo_melhor_rota}): {melhor_rota[:10]}...")
    else:
        print("Erro ao ler o arquivo.")
